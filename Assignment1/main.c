#include<linux/module.h>
#include<linux/init.h>
#include<linux/types.h>
#include<linux/kdev_t.h>        // For MAJOR and MINOR
#include<linux/fs.h>            // For "alloc_chrdev_region()"
#include<linux/cdev.h>			// For cdev
#include<linux/device.h>		// For udev related functions
#include<linux/uaccess.h> // For put_user and get_user macros
#include<linux/random.h>		// For get_random_bytes()
#include"ioctl.h"				// For custom ioctl commands that we have defined


#define SUCCESS 0
#define DEVICE_NAME "adc8"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Atul Pant");
MODULE_DESCRIPTION("Character device driver for 10-bit , 8 channel ADC");




/*************  Declaration of functions used *********************/
static int __init entry_func(void);
static void __exit exit_func(void);
static ssize_t read(struct file *, char __user *, size_t, loff_t *);
static int open(struct inode *, struct file *);
static long ioctl(struct file *, unsigned int, unsigned long);
static int close(struct inode*, struct file*);
/******************************************************************/

/*************************** global variables and data structures ***********************************/

/* file operation structure */
struct file_operations fops = {
	.owner= THIS_MODULE,
	.open = open,
	.read = read,
	.release = close,
	.unlocked_ioctl = ioctl
};

struct cdev _cdev;														// my cdev structure for device
dev_t device_num = 0;													// device number( major + minor )
struct class *cls;														// class structure pointer for device creation in userspace /dev directory
unsigned short adc_reading = 0;											// reading from the channel of ADC
int allignment = 1;														// Allignment of ADC data. 1 for storing bits in lower bits and 2 for storing in higher bits
int adc_channel = 0;													// ADC channel number

/*****************************************************************************************************/


/*********** setting module's init and exit functions **********/
module_init(entry_func);
module_exit(exit_func);
/***************************************************************/


/******************************* Module initialization function *************************************/
static int __init entry_func(void)
{
	printk(KERN_INFO "Driver inserted successfully\n");

	/* Allocating major number and minor number dynamically for our driver */
	if ( alloc_chrdev_region(&device_num,0,1,"my_chardevice") !=0 ) {
		printk(KERN_ALERT "Cannot obtain major and minor num for device\n");
		return -1;
	}


	// creating udev device for userspace access //
	if ((cls = class_create(THIS_MODULE, "my_driver")) == NULL) {
		printk(KERN_ERR "class create error\n");
		unregister_chrdev_region(device_num, 1);
		return -1;
	}
	if (device_create(cls, NULL, device_num, NULL, DEVICE_NAME) == NULL) {
		printk(KERN_ERR "device_create error\n");
		class_destroy(cls);
		unregister_chrdev_region(device_num, 1);
		return -1;
	}

	printk(KERN_INFO "Successfully created your device\n");


	// Initializing cdev structure //
	cdev_init( &_cdev, &fops);

	// Adding device to kernel devices list //
	if( cdev_add( &_cdev, device_num, 1) == -1) {
		printk(KERN_ERR "Cannot add your device to the kernel\n");
		unregister_chrdev_region(device_num, 1);
		return -1;
	}


	printk(KERN_INFO "MAJOR NUM: %d\n", MAJOR(device_num) );
	printk(KERN_INFO "MINOR NUM: %d\n", MINOR(device_num) );

	return SUCCESS;

}
/******************************************************************************************************/


/************************** File operation functions *************************************************/

// Open
static int open(struct inode *f_inode, struct file *f)
{
	printk(KERN_INFO " %s started !\n", __func__ );
	return 0;
}

// Read
ssize_t read(struct file *f, char __user *buff, size_t count, loff_t *offset)
{
	// Function to generate random number
	unsigned short random = 0;
	unsigned short new_num = 0;
	int ret;
	printk(KERN_INFO "%s started ! \n", __func__);

	get_random_bytes(&random, sizeof(unsigned short));
	random %= 1024;
	new_num = random << 6;

	/* I have used switch case statement for all the 8 channels of the ADC. However all are sending the random value generated by "get_random_bytes" function */
	switch(adc_channel) {

		case 0:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		case 1:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		case 2:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		case 3:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		case 4:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		case 5:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		case 6:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		case 7:
			if ( allignment == 1 ) {
				printk( KERN_INFO "Sending value: %hu\n", random);
				if( copy_to_user(buff,&random,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			else {
				printk( KERN_INFO "Sending value: %hu\n", new_num);
				if ( copy_to_user(buff,&new_num,count) ) {
					ret = -EFAULT;
					printk(KERN_ERR "%s: copy_to_user error\n", __func__);
				}
				ret = count;
			}
			break;

		default:
			printk(KERN_ERR "Invalid channel selected\n");
	
	}

	return ret;
}

// Close
static int close(struct inode *i, struct file *fp)
{

	printk(KERN_INFO "Close function started\n");	
	return SUCCESS;
}

// Ioctl
static long ioctl(struct file *fp , unsigned int cmd, unsigned long arg)
{
	printk(KERN_INFO " %s started !\n", __func__ );
	switch(cmd) {
		case SET_CHANNEL:
				get_user(adc_channel, (int __user*)arg);
				printk(KERN_INFO "ADC channel set to %d\n", adc_channel);
				break;

		case SET_ALLIGNMENT:
				get_user(allignment, (int __user*)arg);
				printk(KERN_INFO "allignment set to %d\n", allignment);
				break;

		case GET_ALLIGNMENT:
				put_user(allignment, (int __user*)arg);
				break;
		
		case GET_CHANNEL:
				put_user(adc_channel, (int __user*)arg);
				break;
		default:
				printk(KERN_ERR "Invalid ioctl command\n");
				return -ENOTTY;
	
	}
	return SUCCESS;
}

/**********************************************************************************************************/



/***************************** Module Exit function ***************************************************/
static void __exit exit_func(void)
{
	/* removing our device from kernel */
	cdev_del( &_cdev);
	/* destroy device */
	device_destroy(cls, device_num);
	/* destroying device class */
	class_destroy(cls);
	/* unregistering or giving back the major number and minor numbers to the kernel */
	unregister_chrdev_region(device_num, 1);
	printk(KERN_INFO "Driver removed successfully\n");
}
/******************************************************************************************************/

